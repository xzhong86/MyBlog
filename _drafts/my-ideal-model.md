
# 整体构想

Trace-Driven，严格划分行为模型和时序模型。为了支持高精度仿真，行为模型需要支持可回退，可更正特性。

明确人员角色，理清模型栈逻辑视图

## 行为模型：
 * 可回退：CycleModel(CM)可以强制FunctionModel(FM)去沿着预测错误的方向执行指令，并且将错误路径的trace输送给CM，CM发生flush之后（可能回到正确路径，也可能不会），FM恢复到flush点的状态，并沿着flush之后的新路径执行（可能还在错误路径上）。（可回退 其实就要求行为模型的指令执行效果要等到commit时才落实）
 * 可更正：CycleModel(CM)模型执行 exclusive store或者atomic 指令时，发现时序模型的执行结果和Trace不一致，可以更正FunctionModel对应的执行结果，并且让FM回退 并根据更正的结果重新执行并刷新trace信息；如果一条指令已经commit却被更正就报错。

此外，还希望行为模型做到：
 * 文档式指令行为描述，同时能高速执行。
 * 自由地在高速模式和单步模式切换，单步模式也能高效执行。
 * 抽象封装，接口简单明确的CPU类型封装。可以作为库在其他地方使用

## 时序模型

 1. Trace-Driven，好处很多，缺点也明显。
 1. 混合cycle-driven和event-driven建模。
 1. 模型中涉及最多的统计和参数代码，需要配合代码生成来做。（其实一开始的DSL可以从这里入手）
 1. 理想：构建一套DSL语言来做时序建模
    * 使用DSL能约束建模人员的代码行为，减少不规范的写法。而且后后期优化留出空间，有利于做模型性能优化。
 1. 理想：在运行时根据加载的参数来优化模型代码。因为运行后，参数基本就是常数了。
 1. 以上理想难以实现的情况下，可以考虑用Java/Scala之类的语言建模。

