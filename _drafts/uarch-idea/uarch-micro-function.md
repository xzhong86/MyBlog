# 微函数构想

## 概述
    微函数方案，通过软硬件结合的方式，小幅度修改 软件、指令架构、硬件微架构， 实现等效以及超过OOOF的性能提升。


## 微函数定义

    位于ABI定义的标准函数内，与标准函数共享大部分 *临时寄存器（temporary register） 又保有若干（比如4个）微函数使用的临时寄存器，标准函数和微函数可以约定若干参数和返回值寄存器（比如4个），具体可以由编译器控制。 微函数使用branch and link 指令来调用，并且将返回地址记录到LR（RA）。

    微函数不能调用函数或者微函数，可以有循环，但是不能嵌套循环。（嵌套循环应该做成标准函数内的循环 调用 带循环的微函数）

    微函数只能修改 微函数自己的 临时寄存器 和 参数、返回值寄存器 。微函数之后的指令 只能通过微函数返回寄存器与微函数指令序列产生关联（数据依赖）。微函数没有栈操作。

    微函数跳转范围小，可以使用较小的立即数，也可以和条件branch指令合并出 *条件微调用指令。新增指令实现微函数调用更好。


## 硬件优化
    对于微函数，硬件可以同时执行微函数内的指令和微函数之后的指令，微函数外的指令只能通过微函数返回值寄存器获得微函数的执行结果，并且借此和微函数内的指令建立数据依赖（也只允许如此产生依赖）。

    微函数内部发生的Branch flush不影响微函数外的指令执行，即不会flush外部指令。微函数返回值寄存器在微函数返回时才能ready（或者返回指令处于nonflush状态时）来唤醒之后的依赖于微函数结果的指令。异常和中断依然会flush之后 和 外部的所有指令。

    条件调用微函数指令 会投机执行，故有可能条件不成立 或者 本身被flush了， 此时微函数指令被整体flush。

    原则上，微函数内的内存访问不与外部有关联，如果出现 访存竞争，硬件产生nuke flush。

    微函数内包含循环的情况：微函数带循环时，无法知道具体会有多少条指令，也很难界定flush的范围，故需要 o3f-thread-id 来标记该微函数，flush就刷掉相同 o3f-thread-id 的UOP。

    微函数支持最好结合O3F。微函数的本质就是一种特殊的O3F segment，只是可以结合编译器以及寄存器约束来简化O3F的segment侦测以及寄存器分析；同时允许微函数带有循环以及微函数flush不影响外部 这两点又能带来超越O3F的性能。一个微函数由一个O3F-thread来执行，多个O3F-thread 也能同时执行多个微函数。

    硬件可以主动侦测detect 微函数，也可以将标准函数当做微函数来处理（如果符合微函数标准）。硬件侦测可以获得准确的临时寄存器和参数寄存器数量（如果硬件和软件没有约定数量）。

    硬件最好新增微调用、条件微调用指令，来指示调用的指令序列是微函数，符合微函数标准。编译器也使用这些指令调用微函数。

    硬件可能需要新增double move指令，即单指令完成两对寄存器的move(copy) 操作。该指令用来准备微函数的参数或许有帮助。

    硬件可以有微函数cache，类似mopcache，加速小型微函数的处理。

    微函数外（之后的指令）读取微函数内的临时寄存器（非返回值寄存器），其结果是未定义的。（这一点编译器能够保证，但是也和ARM架构定义会有冲突，这个冲突不影响带微函数的程序、库 调用 常规程序、库，因为ARM ABI并没有破坏）。



## 小结
    我认为：微函数可以让硬件用更简单的方法获得 等同甚至超过O3F的性能。通过编译器指示的微函数，硬件可以不用侦测O3F segment，也不用分析记录segment 使用的寄存器的情况（因为已经有和软件约定了）。

    通过微函数，最终可以将处理器的 指令级并行（ILP）提升到 微函数级并行（mFLP）。有点类似BlockISA的块并行BLP，但是对架构定义的改动很小；又类似于O3F的segment并行，同时硬件实现简单很多。同时 微函数限定了flush范围，使得能够超越 BlockISA 和 O3F。

    微函数 的限定范围flush 一定程度实现了 never-flush 的愿望（很大程度获得了其收益？），同时硬件不会太复杂。



## 编译器优化
    微函数能将函数内的一些公共处理流程放到一个微函数内，提高指令密度。（传统编译器会将小函数内联展开来降低 函数调用开销 以提升性能，这举措同时也降低了指令密度）。
    利用微函数的硬件优化特性，原本的循环展开也可以做成循环内调用微函数，利用硬件并行来提高性能（循环内的指令大于 ~10或许更有效）。 嵌套循环可以将最内层循环做成微函数，充分利用硬件并行。
    对于 strlen/strcpy/strcmp 等 循环简单但是循环次数难以预测的函数，可以在标准函数内部产生一个微函数来避免硬件flush影响性能。如果此类函数进行内联inline优化，也可以内联成函数内的微函数。

    对于容易猜错同时又不影响整体执行流的代码块可以放到微函数中去。（缩小flush影响范围）


## DBT优化
    DBT工具能发现的可优化成微函数的指令序列，可以优化为微函数 且通过 微函数调用 来执行。



## 名词解释
    临时寄存器：一般包括ABI规定的 temporaries 临时寄存器 和 argument 参数寄存器 和 返回值寄存器

    微调用指令 条件微调用指令： 调用微函数的指令，指示目标指令序列是一个微函数。

    O3F： Out-Of-Order Fetch。



## 简单例子
    这个例子中两个strlen可以在硬件上同时进行，并且不产生flush，如果扩展此用例，对N个字符串长度进行求和，可以获得更大的并行度，而且都不会产生flush，此时制约并行度的就是硬件支持多少个线程了。
    传统O3处理器上会产生至少两次flush（认为string长度不可知），微函数优化下可以不产生flush。 
    传统O3处理器在第一个strlen时因为预测循环跳转，导致流水线上充满第一个循环的指令，第二个循环无法并行执行。
    传统O3处理器上，即使BP预测了第一个循环的结束并将第二个循环送入处理器，也会因为第一个循环预测大概率错误（string长度不可知），导致第二个循环的指令被flush。

```asm
func_add_strlen:
    // argument: a0: first string pointer, a1: second string pointer, 
    // return: sum of length of two strings
    // x9-x12 micro func temp reg, x0-x3 micro func arg/return reg
    push x30, [sp], #8
    ...
    mov x14, x1
    cmp x0, #0
    blm.ne micro_strlen
    mov x15, x0
    mov x0, x14
    cmp x0, #0
    blm.ne micro_strlen
    add x15, x15, x0
    pop  x30, [sp, #-8]!
    ret
micro_strlen:
    mov x9, #0
  1:
    ldrb x10, [x0], #1
    add  x9, x9, #1
    cbnz x10, 1b
    sub  x0, x9, #1
    ret
    .end func_add_strlen
```    


    其他还有一些场景，比如二叉树查找、二分查找， 内部的分支指令都具有很强的不确定性，都能通过微函数约束其flush的影响范围。

    那些处理流程很长的函数，可以拆分成若干微函数，可以约束flush并提高并行。如 函数有4个步骤 A -> B -> C -> D ， 四个步骤比较独立（耦合低），每个步骤内部还有很多分支判断（没有复杂循环），这时拆成四个微函数会有不错的效果（满足微函数条件）。


